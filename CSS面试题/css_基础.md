# cssj基础

## 1. css选择器及其优先级

**基本选择器**

| 选择器  | 语法   | 权重   |
|-------------- | -------------- | -------------- |
|  id选择器   | #id| 100  |
| 类选择器 | .class | 10 |
| 属性选择器 | selector[prop] | 10 |
| 伪类选择器 | :hover, :first-child, ... | 10 |
| 标签选择器 | tagname | 1 |
| 伪元素选择器 | ::before, ... | 1 |

注: 

伪类选择器

- 状态伪类选择器: :link, :visited, :hove, :active, :focus 
- 结构伪类选择器: E F: first-child, E F:last-child, E F:nth(n) - child, 还有nth-of-type(n)等...
- 其他的较少用到的伪类选择器: 否定伪类选择器, 读写伪类选择器, 表单伪类选择器, 目标伪类状态选择器, ui元素状态伪类选择器 ...

**层次选择器**

| 选择器 | 语法 | 功能 | 
|--- |--- |--- | 
| 兄弟选择器 | E + F | 选择紧跟元素E的元素F
| 后代选择器 | E F | 选择元素E的后代层级中的所有元素F
| 子选择器 | E > F | 选择元素E的子级的所有元素F

**其他选择器**

| 选择器 | 语法 | 功能 |
|--- |--- |--- |
| 通配符选择器 | * | 选择所有类型元素 |
| 群组选择器 | selector1, selector2, ... | 同时选择多个选择器对应的元素 |
| 多类选择器 | selector1selector2... | 选择同时满足选择器select1, selector2, ... 的元素 |


**选择器优先级**

对于开发者而言, 选择器优先级计算如下:

- a={0, 1}, 样式属性声明对应的属性值当中是否有 `!important` 关键字
- b={0, 1}, 样式规则集是否是**行内样式**
- c=n_c, id选择器, n_c为选择器组合当中id选择器的数目
- b=n_b, 类选择器, 属性选择器, 伪类选择器, n_b为选择器组合当中这些选择器出现的次数
- d=n_d, 标签选择器, 伪元素选择器, n_d为选择器组合当中这些选择器出现的次数
- e=n_o, 通配符选择器

计算公式: a * 10000 + b * 1000 + c * 100 + b * 10 + d * 1 + e * 0

注: 
- 对于多类选择器, 层次选择器这种, 会记录其中包含的选择器个数. 例如多类选择器#eamilInput.center.red:hover中, 类选择器的个数为2, 那么对应的b=n_b=2
- 通配符选择器选择器权重为0, 它不具备特殊性. 另外, 元素继承的样式属性也不具备特殊性, 权重为0. 虽然继承属性和通配符选择器设置的样式属性权重均为0, 但是, 通配符选择器的优先级更高

## 替换元素是什么?

替换元素是通过改变某个属性就可以替换内容的元素, 比如修改img标签的src属性, 就可以更换其中的图像

替换元素的特性

1. 具有自己的默认尺寸. 比如在谷歌浏览器中, img元素在内容为空的情况下, 默认尺寸为300×150
2. 内容样式不受外部的css影响
3. 所有替换元素都是内联元素, 不过它们的默认display不太一样, 有的是inline, 有的是inline-block
4. 有自己独特的默认css样式. 比如, vertical-align的默认值是baseline, 即以行盒子的基线为基准进行对齐. 
   替换元素不是将内容与基线进行对齐, 而是以元素的下边界与基线进行对齐

替换元素的尺寸

1. 替换内容的固有尺寸. 比如img元素src属性指向的图像资源的像素尺寸, 以及宽高比例
2. html尺寸. 即通过html属性`width, height`指定的尺寸
3. css尺寸. 通过css样式属性width和height指定的尺寸

尺寸优先级

- css尺寸 > html尺寸 > 替换内容的固有尺寸
- 如果有css尺寸或者html尺寸(两者只有一个), 且只指定width或者height当中的一个尺寸, 那么会按照替换内容的宽高比例将另一尺寸进行缩放
- 如果同时有css尺寸和html尺寸, 那么css尺寸会覆盖html尺寸

## 常见的图片格式及实用场景

1. BMP. 无损格式, 文件体积较大
2. GIF. 颜色位数是8-bit, 文件体积小, 但是色彩不够丰富. 支持动图
3. JPEG.有损格式, 文件体积小, 色彩丰富, 但是因为有损格式, 所以图片放大以后会有较明显的模糊
4. PNG. 无损格式, 色彩丰富
5. SVG. 矢量图, 文件保存的是形状路径节点和颜色样式, 在放大的时候不会失真, 常用于logo

## 对精灵图(css sprites)的理解

精灵图是将多张小的图片的内容汇总, 用一张图片来展示, 然后通过background-image属性将其作为元素的背景图, 在通过background-position, repeat对背景图片进行定位

使用精灵图的优点

1. 减少图片请求的次数. 多张图片需要发送多次http请求, 而单张图片只需要发送一次http请求
2. 减少图片的总体积. 因为三张图片的总体积比包含了三张图片内容的单张图片要大

缺点: 不好维护. 因为精灵图需要通过photoshop等图像处理工具进行合成, 如果频繁更改精灵图的内容的话, 修改的时间成本较大

## css优化和提高性能的方法有哪些?

**加载性能**

1. 将css进行压缩, 减少文件体积
2. 使用link标签引入css文件, 而不是用@import关键字, 因为, link引入的文件会在页面开始加载的时候发送资源请求, 而@import导入的css文件需要等到页面加载完以后, 才会加载和解析 

**选择器性能**

1. 减少选择器嵌套的层级
2. 使用更为精确的选择器, 比如尽量使用类, 或者id选择元素. 避免使用后代选择器和通配符选择器, 以及尽量少的标签选择器.
3. 将关键选择器放在选择器的最右端, 因为选择器匹配是从最右端开始的.
4. 了解哪些样式规则是可继承的, 然后避免重复指定相同的规则

**渲染性能**

1. 慎用性能消耗较大的绝对定位和浮动
2. 对于动态样式, 尽量减少页面回流和重绘
3. 去除空规则{}
4. 不滥用web字体. 因为web字体体积比较大, 影响页面加载性能

**可维护性**: 模块化管理css文件, 将相同逻辑的css样式抽离出来

## 单行和多行文本溢出隐藏

单行文本溢出隐藏
```html
.text-block {
    overflow: hidden;
    text-overflow: ellipsis;
    white-spacing: nowrap;
}
```

多行文本溢出隐藏

```html
.text-area-block {
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
}
```

## 对媒体查询的理解

媒体查询就是查询设备的视口尺寸, 然后设定一个表达式, 在表达式为true的情况下应用表达式对应的样式文件, 或者样式规则块. 比如:

1. `<link rel="style-sheet" href="style.css" media="screen and (max-width: 1000px)">`, 当设备的视口像素小于等于1000px时, 引入style.css文件
2. `@media only screen and (max-width: 1000px) {...}`

这样可以根据不同的设备尺寸应用不同的样式规则

另外媒体查询通常与meta标签连用, 在head标签中指定: `<meta name="viewport" content="width=device-width, initial-scale=1">`
